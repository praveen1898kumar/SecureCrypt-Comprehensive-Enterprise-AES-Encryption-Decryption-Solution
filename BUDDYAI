To create the ASP.NET Core project for the BuddyAI onboarding chatbot, follow these steps:

***

### Step 1: Install Prerequisites

- Install [.NET SDK (7.0 or later)](https://dotnet.microsoft.com/en-us/download)
- Install a code editor like [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/) or [Visual Studio Code](https://code.visualstudio.com/)

***

### Step 2: Create a New ASP.NET Core Web App

Open a terminal or command prompt and run:

```bash
dotnet new webapp -n BuddyAIOnboardingAspNetCore
cd BuddyAIOnboardingAspNetCore
```

This creates a new Razor Pages web application inside a folder named **BuddyAIOnboardingAspNetCore**.

***

### Step 3: Add Required NuGet Packages

For PDF reading and HTTP calls, install:

```bash
dotnet add package UglyToad.PdfPig        # For PDF text extraction
dotnet add package Microsoft.Extensions.Http
```

If you want to use other PDF libraries like iText7, similarly add them.

***

### Step 4: Open the Project in Your Editor

- In Visual Studio: Open the project folder.
- In VS Code: Run `code .` inside the project folder.

***

### Step 5: Add Your Code Files and Folders

Manually create the folders and files as per the structure explained earlier:

- Create `Models`, `Controllers`, `Pages`, `wwwroot/css`, `wwwroot/js` folders.
- Add the files (`Program.cs`, `ChatbotController.cs`, `EmbeddingService.cs`, `ChatMessage.cs`, `PdfTextChunk.cs`, `Index.cshtml`, `Index.cshtml.cs`, `site.css`, `chat.js`) with the content as shared.

***

### Step 6: Configure Program.cs

Replace the existing `Program.cs` content with the example code provided earlier to configure services and request pipeline.

***

### Step 7: Run the application

To run the project, in terminal inside project folder:

```bash
dotnet run
```

Open your browser to the URL it shows, typically `https://localhost:5001`.

***

If you prefer, I can guide step-by-step with detailed commands and code snippets for each file creation after project setup. Would that be helpful?



----------------------------


To convert the provided Python Streamlit AI onboarding chatbot into an ASP.NET Core web application with an attractive UI, the approach is to:

1. Create an ASP.NET Core web project with Razor Pages or MVC (favoring Razor Pages for simplicity).
2. Implement PDF text extraction using a .NET PDF library (like PdfPig or iText7).
3. Integrate Hugging Face transformer embeddings or use OpenAI GPT or Hugging Face API via HTTP clients.
4. Implement cosine similarity and chunk search logic in C#.
5. Build a chat interface with creative, modern styling using CSS and Bootstrap or Tailwind.
6. Manage chat history in session or client-side.

***

### Recommended Project & Files Structure

```
BuddyAIOnboardingAspNetCore/
│
├── Controllers/
│   └── ChatbotController.cs
│
├── Models/
│   ├── ChatMessage.cs
│   ├── PdfTextChunk.cs
│   └── EmbeddingService.cs
│
├── Pages/
│   ├── Index.cshtml
│   └── Index.cshtml.cs
│
├── wwwroot/
│   ├── css/
│   │   └── site.css
│   └── js/
│       └── chat.js
│
├── appsettings.json
├── Program.cs
└── BuddyAIOnboardingAspNetCore.csproj
```

***

### Brief overview of each file

- **Program.cs**: Set up ASP.NET Core app, services, routing.
- **Pages/Index.cshtml + Index.cshtml.cs**: Main UI page and server-side handler.
- **Controllers/ChatbotController.cs**: Endpoint for chat requests.
- **Models/ChatMessage.cs**: Chat message model (role, content).
- **Models/PdfTextChunk.cs**: Class for PDF chunk and embedding storage.
- **Models/EmbeddingService.cs**: Logic contacting HuggingFace/OpenAI for embeddings and answers.
- **wwwroot/css/site.css**: Custom styling for creative/chat UI.
- **wwwroot/js/chat.js**: JS handling chat UI front-end interactivity and ajax calls.

***

### Step-by-step implementation blueprint

***

### 1. Program.cs

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddRazorPages();
builder.Services.AddHttpClient(); // For API calls
builder.Services.AddSession();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Error");
}
app.UseStaticFiles();

app.UseRouting();

app.UseSession();

app.MapRazorPages();

app.Run();
```

***

### 2. Models/ChatMessage.cs

```csharp
public class ChatMessage
{
    public string Role { get; set; } = "user";  // or "assistant"
    public string Content { get; set; } = string.Empty;
}
```

***

### 3. Models/PdfTextChunk.cs

```csharp
public class PdfTextChunk
{
    public string Text { get; set; }
    public float[] Embedding { get; set; }

    public PdfTextChunk(string text, float[] embedding)
    {
        Text = text;
        Embedding = embedding;
    }
}
```

***

### 4. Models/EmbeddingService.cs

- Does embedding via Hugging Face API or OpenAI API HTTP calls.
- Includes cosine similarity calculation.
- Finds relevant chunks.
- Calls AI model chat completions with context.

Example using HttpClient and imaginary API endpoints:

```csharp
using System.Net.Http.Headers;
using System.Net.Http.Json;
using System.Text.Json;

public class EmbeddingService
{
    private readonly HttpClient _httpClient;
    private readonly string HuggingFaceToken;

    private readonly string EmbeddingEndpoint = "https://api-inference.huggingface.co/models/sentence-transformers/all-mpnet-base-v2";
    private readonly string ChatCompletionEndpoint = "https://router.huggingface.co/v1/chat/completions";

    public EmbeddingService(HttpClient httpClient, string huggingFaceToken)
    {
        _httpClient = httpClient;
        HuggingFaceToken = huggingFaceToken;
        _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", HuggingFaceToken);
    }

    // Extract embedding for given text (same as python embed_text)
    public async Task<float[]> GetEmbeddingAsync(string text)
    {
        var requestPayload = new { inputs = text };

        var response = await _httpClient.PostAsJsonAsync(EmbeddingEndpoint, requestPayload);
        response.EnsureSuccessStatusCode();

        var json = await response.Content.ReadAsStringAsync();
        using var doc = JsonDocument.Parse(json);

        // Expecting response is an array of floats (embedding vector)
        var embeddingElement = doc.RootElement;

        // HuggingFace embedding outputs just array of floats
        int length = embeddingElement.GetArrayLength();
        float[] embedding = new float[length];
        for (int i = 0; i < length; i++)
        {
            embedding[i] = embeddingElement[i].GetSingle();
        }

        return embedding;
    }

    public float CosineSimilarity(float[] vec1, float[] vec2)
    {
        float dot = 0;
        float normA = 0;
        float normB = 0;
        for (int i = 0; i < vec1.Length; i++)
        {
            dot += vec1[i] * vec2[i];
            normA += vec1[i] * vec1[i];
            normB += vec2[i] * vec2[i];
        }
        return dot / ((float)Math.Sqrt(normA) * (float)Math.Sqrt(normB));
    }

    // Find top K chunks matching query based on cosine similarity
    public async Task<List<PdfTextChunk>> FindSimilarChunksAsync(string query, List<PdfTextChunk> chunks, int topK = 4)
    {
        var queryEmbedding = await GetEmbeddingAsync(query);
        var similarities = chunks.Select(c => new { Chunk = c, Score = CosineSimilarity(queryEmbedding, c.Embedding) })
                                 .OrderByDescending(x => x.Score)
                                 .Take(topK)
                                 .Select(x => x.Chunk)
                                 .ToList();
        return similarities;
    }

    // Call Llama-3 chat completions with context
    public async Task<string> AskLlama3WithContextAsync(string prompt)
    {
        var payload = new
        {
            model = "meta-llama/Llama-3.1-8B-Instruct:cerebras",
            messages = new[]
            {
                new { role = "user", content = prompt }
            }
        };

        using var request = new HttpRequestMessage(HttpMethod.Post, ChatCompletionEndpoint)
        {
            Content = JsonContent.Create(payload)
        };
        request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", HuggingFaceToken);

        var response = await _httpClient.SendAsync(request);
        response.EnsureSuccessStatusCode();

        var responseContent = await response.Content.ReadAsStringAsync();
        using var doc = JsonDocument.Parse(responseContent);

        var answer = doc.RootElement.GetProperty("choices")[0]
                                   .GetProperty("message")
                                   .GetProperty("content")
                                   .GetString();

        return answer ?? "No response from the AI model.";
    }
}

```

***

### 5. Controller: Controllers/ChatbotController.cs

Handles chat post requests, receives user question, calls embedding service, returns answer.

```csharp
using Microsoft.AspNetCore.Mvc;
using UglyToad.PdfPig;
using System.Text;

[ApiController]
[Route("api/[controller]")]
public class ChatbotController : ControllerBase
{
    private readonly EmbeddingService _embeddingService;

    // Use your actual PDF path here or from config
    private const string PdfFilePath = @"C:\Users\Adhiraj\Downloads\BuddyAI Project\BuddyAI-Onboarding-Testing-Doc.pdf";

    // Store chunks and embeddings in static cache to avoid recomputing each time
    private static List<PdfTextChunk> _chunks = null;

    public ChatbotController(EmbeddingService embeddingService)
    {
        _embeddingService = embeddingService;

        if (_chunks == null)
        {
            _chunks = LoadAndEmbedPdfChunks(PdfFilePath).Result;
        }
    }

    // Extracts text chunks from PDF and generates embeddings
    private async Task<List<PdfTextChunk>> LoadAndEmbedPdfChunks(string pdfPath, int chunkSize = 1000)
    {
        var chunks = new List<string>();
        var fullTextBuilder = new StringBuilder();

        // Extract full text from PDF
        using (PdfDocument document = PdfDocument.Open(pdfPath))
        {
            foreach (var page in document.GetPages())
            {
                fullTextBuilder.AppendLine(page.Text);
            }
        }

        string fullText = fullTextBuilder.ToString();

        // Split full text into chunks
        for (int i = 0; i < fullText.Length; i += chunkSize)
        {
            int length = Math.Min(chunkSize, fullText.Length - i);
            var chunk = fullText.Substring(i, length).Trim();
            if (!string.IsNullOrEmpty(chunk))
            {
                chunks.Add(chunk);
            }
        }

        var pdfTextChunks = new List<PdfTextChunk>();

        // Generate embeddings for each chunk
        foreach (var chunkText in chunks)
        {
            var embedding = await _embeddingService.GetEmbeddingAsync(chunkText);
            pdfTextChunks.Add(new PdfTextChunk(chunkText, embedding));
        }

        return pdfTextChunks;
    }

    [HttpPost("ask")]
    public async Task<IActionResult> AskAsync([FromBody] ChatMessage chatMessage)
    {
        if (string.IsNullOrWhiteSpace(chatMessage.Content))
        {
            return BadRequest("Message content cannot be empty.");
        }

        // Find most relevant chunks based on query embedding similarity
        var relevantChunks = await _embeddingService.FindSimilarChunksAsync(chatMessage.Content, _chunks);

        var contextText = string.Join("\n\n", relevantChunks.Select(c => c.Text));

        var prompt = $"You are BuddyAI, an onboarding assistant helping new project members. " +
                     $"Answer ONLY based on the following information:\n\n{contextText}\n\nQuestion: {chatMessage.Content}\n\n" +
                     "Provide a clear, helpful, and friendly answer.";

        var answer = await _embeddingService.AskLlama3WithContextAsync(prompt);

        return Ok(new ChatMessage { Role = "assistant", Content = answer });
    }
}

```

***

### 6. UI - Pages/Index.cshtml

Beautiful chat UI using Bootstrap:

```html
@page
@model IndexModel
@{
    ViewData["Title"] = "BuddyAI Onboarding Assistant";
}
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" />
<div class="container py-4">
    <h1 class="mb-4"><span>🤖</span> BuddyAI - Your Friendly Onboarding Companion 🚀</h1>
    <div class="card" style="height:600px; overflow-y:auto;" id="chatWindow">
        <ul class="list-group list-group-flush" id="chatMessages">
            <!-- Messages appended here -->
        </ul>
    </div>
    <div class="input-group mt-3">
        <input type="text" id="userInput" class="form-control" placeholder="💡 Ask me anything about the onboarding document:" />
        <button class="btn btn-primary" id="sendMessageBtn">Send</button>
    </div>
</div>

<script src="https://code.jquery.com/jquery-3.6.1.min.js"></script>
<script src="/js/chat.js"></script>
```

***

### 7. UI Backend - Pages/Index.cshtml.cs

```csharp
using Microsoft.AspNetCore.Mvc.RazorPages;

public class IndexModel : PageModel
{
    public void OnGet()
    {
    }
}
```

***

### 8. wwwroot/js/chat.js

AJAX for external call and UI interaction:

```js
$(function () {
    const chatMessages = $("#chatMessages");
    const chatWindow = $("#chatWindow");

    function appendMessage(role, message) {
        let bg = role === "user" ? "bg-primary text-white" : "bg-light text-dark";
        let align = role === "user" ? "text-end" : "text-start";
        chatMessages.append(`<li class="list-group-item ${bg} ${align}"><strong>${role === "user" ? "You" : "BuddyAI"}:</strong> ${message}</li>`);
        chatWindow.scrollTop(chatWindow.prop("scrollHeight"));
    }

    $("#sendMessageBtn").click(async function () {
        const userInput = $("#userInput");
        const message = userInput.val().trim();
        if (!message) return;

        appendMessage("user", message);
        userInput.val("");
        appendMessage("assistant", "🤖 BuddyAI is thinking...");

        try {
            let response = await fetch("/api/chatbot/ask", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ content: message, role: "user" }),
            });
            let data = await response.json();

            chatMessages.children("li.bg-light:contains('🤖 BuddyAI is thinking...')").last().remove();
            appendMessage("assistant", data.content);
        } catch (err) {
            chatMessages.children("li.bg-light:contains('🤖 BuddyAI is thinking...')").last().text("⚠️ Error getting response.");
        }
    });

    $("#userInput").keypress(function (e) {
        if (e.which == 13) {
            $("#sendMessageBtn").click();
            return false;
        }
    });
});
```

***

### 9. Styling - wwwroot/css/site.css

Add creative touches such as colors, animations, and fonts, you can extend:

```css
body {
    background: linear-gradient(135deg, #3a3d8f, #6b62b9);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
}

#chatWindow {
    background-color: #1a1a2e;
    border-radius: 8px;
    padding: 10px;
}

.list-group-item.bg-primary {
    background-color: #4e54c8 !important;
    border-color: #4e54c8 !important;
}

.list-group-item.bg-light {
    background-color: #e3e3e3 !important;
    color: #333;
}

h1 span {
    animation: pulse 1.5s infinite;
    display: inline-block;
}

@keyframes pulse {
    0% { transform: scale(1); opacity: 0.7; }
    50% { transform: scale(1.1); opacity: 1; }
    100% { transform: scale(1); opacity: 0.7; }
}
```

***

### Additional Notes

- PDF text extraction should be done during app startup or on file upload, using libraries like PdfPig (available as NuGet).
- Manage API tokens securely (e.g., user secrets, environment variables).
- For scaling, replace in-memory chunk storage with a database or cache.
- Consider async programming pattern for all I/O calls.
- Add error handling and UX enhancements (loaders, rich messages).

***

This structure and code gives a full ASP.NET Core chat app inspired by your Python Streamlit chatbot, with creative UI and Hugging Face/OpenAI integration. If you want, I can provide the full code for each file explicitly one by one. Would that be helpful?
